<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <        // Create Rubik's cube structure (complete 3x3x3)
        function createRubiksCube() {
            const cubeSize = 1.02; // Slightly larger for overlap and perfect sticking
            const spacing = 1.0; // Perfect spacing for seamless 3x3x3 connection
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        // Skip the center cube (it's our main cube)
                        if (x === 0 && y === 0 && z === 0) continue;
                        
                        // Skip cubes on the right side (x = 1)
                        if (x === 1) continue;"viewport" content="width=device-width, initial-scale=1.0">
    <title>Shapes</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow-x: hidden;
            font-family: Arial, sans-serif;
            height: 250vh; /* Reduced scrollable height for less scrolling */
        }
        
        #container {
            position: fixed;
            width: 100vw;
            height: 100vh;
            top: 0;
            left: 0;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene, camera, and renderer setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        document.getElementById('container').appendChild(renderer.domElement);

        // Animation state variables
        let isSpinning = true;
        let scrollProgress = 0;
        let rubiksCubes = [];
        let mainCube;
        let ballGeometry;

        // Create main cube geometry and materials
        const geometry = new THREE.BoxGeometry(1.02, 1.02, 1.02); // Slightly larger for overlap and perfect connection
        
        // Create materials for each face with different colors
        const materials = [
            new THREE.MeshLambertMaterial({ color: 0xff0000 }), // Right face - Red
            new THREE.MeshLambertMaterial({ color: 0x00ff00 }), // Left face - Green
            new THREE.MeshLambertMaterial({ color: 0x0000ff }), // Top face - Blue
            new THREE.MeshLambertMaterial({ color: 0xffff00 }), // Bottom face - Yellow
            new THREE.MeshLambertMaterial({ color: 0xff00ff }), // Front face - Magenta
            new THREE.MeshLambertMaterial({ color: 0x00ffff })  // Back face - Cyan
        ];
        
        mainCube = new THREE.Mesh(geometry, materials);
        scene.add(mainCube);

        // Create ball geometry for floating balls transformation
        ballGeometry = new THREE.SphereGeometry(0.5, 16, 16);

        // Create Rubik's cube structure (without right side cubes)
        function createRubiksCube() {
            const cubeSize = 1.02; // Slightly larger for overlap and perfect sticking
            const spacing = 1.0; // Perfect spacing for seamless 3x3x3 connection
            
            let cubeIndex = 0;
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        // Skip the center cube (it's our main cube)
                        if (x === 0 && y === 0 && z === 0) continue;
                        
                        // Skip the right side cubes (x = 1)
                        if (x === 1) continue;
                        
                        const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                        const cubeMat = materials.map(mat => mat.clone());
                        const cube = new THREE.Mesh(cubeGeo, cubeMat);
                        
                        // Set initial position (spread out)
                        const initialSpreadPosition = new THREE.Vector3(x * spacing * 8, y * spacing * 8, z * spacing * 8);
                        cube.position.copy(initialSpreadPosition);
                        cube.initialPosition = initialSpreadPosition;
                        cube.targetPosition = new THREE.Vector3(x * spacing, y * spacing, z * spacing);
                        
                        // Calculate pyramid position
                        cube.pyramidPosition = calculatePyramidPosition(cubeIndex);
                        
                        // Calculate floating ball position
                        cube.ballPosition = calculateBallPosition(cubeIndex);
                        
                        // Calculate floating up position
                        cube.floatingUpPosition = calculateFloatingUpPosition(cubeIndex);
                        
                        // Create ball mesh for transformation - use same color as cube
                        const ballMat = new THREE.MeshLambertMaterial({ 
                            color: cubeMat[0].color // Use the same color as the cube's first material
                        });
                        cube.ballMesh = new THREE.Mesh(ballGeometry, ballMat);
                        cube.ballMesh.visible = false;
                        scene.add(cube.ballMesh);
                        
                        cube.visible = false;
                        
                        scene.add(cube);
                        rubiksCubes.push(cube);
                        cubeIndex++;
                    }
                }
            }
        }

        // Calculate pyramid positions
        function calculatePyramidPosition(index) {
            // Create a pyramid with 4 layers
            const pyramidLayers = [
                // Bottom layer (3x3)
                [
                    new THREE.Vector3(-1, -2, -1), new THREE.Vector3(0, -2, -1), new THREE.Vector3(-1, -2, 0),
                    new THREE.Vector3(0, -2, 0), new THREE.Vector3(-1, -2, 1), new THREE.Vector3(0, -2, 1),
                    new THREE.Vector3(1, -2, -1), new THREE.Vector3(1, -2, 0), new THREE.Vector3(1, -2, 1)
                ],
                // Second layer (2x2)
                [
                    new THREE.Vector3(-0.5, -1, -0.5), new THREE.Vector3(0.5, -1, -0.5),
                    new THREE.Vector3(-0.5, -1, 0.5), new THREE.Vector3(0.5, -1, 0.5)
                ],
                // Third layer (1x1)
                [
                    new THREE.Vector3(0, 0, 0)
                ],
                // Top layer (1 cube)
                [
                    new THREE.Vector3(0, 1, 0)
                ]
            ];
            
            // Flatten the pyramid layers and assign positions
            const allPyramidPositions = pyramidLayers.flat();
            
            // If we have more cubes than pyramid positions, distribute extras around the base
            if (index < allPyramidPositions.length) {
                return allPyramidPositions[index];
            } else {
                // Place extra cubes around the base in a circle
                const angle = (index - allPyramidPositions.length) * (Math.PI * 2 / 6);
                const radius = 2.5;
                return new THREE.Vector3(
                    Math.cos(angle) * radius,
                    -2.5,
                    Math.sin(angle) * radius
                );
            }
        }

        // Calculate floating ball positions
        function calculateBallPosition(index) {
            // Create floating positions in a cloud-like formation
            const radius = 4 + Math.random() * 6; // Random radius between 4-10
            const theta = (index * 0.618) * Math.PI * 2; // Golden angle for spiral distribution
            const phi = Math.acos(1 - 2 * Math.random()); // Random phi for sphere distribution
            
            return new THREE.Vector3(
                radius * Math.sin(phi) * Math.cos(theta),
                (Math.random() - 0.5) * 8, // Random Y between -4 and 4
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // Calculate floating up positions for balls
        function calculateFloatingUpPosition(index) {
            // Balls float up from their current position
            const radius = 2 + Math.random() * 4; // Smaller radius when floating up
            const theta = (index * 0.618) * Math.PI * 2; // Golden angle for spiral distribution
            
            return new THREE.Vector3(
                radius * Math.cos(theta),
                8 + Math.random() * 4, // Float up high
                radius * Math.sin(theta)
            );
        }

        createRubiksCube();

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Position camera
        camera.position.z = 5;

        // Mouse interaction variables
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;

        // Mouse move event listener
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            targetRotationX = mouseY * 0.5;
            targetRotationY = mouseX * 0.5;
        });

        // Scroll event listener
        window.addEventListener('scroll', () => {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            scrollProgress = Math.min(scrollTop / maxScroll, 1);
            
            // Stop spinning when scrolling starts
            if (scrollProgress > 0.05) {
                isSpinning = false;
            } else {
                isSpinning = true;
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Auto-rotate the main cube only if spinning
            if (isSpinning) {
                mainCube.rotation.x += 0.01;
                mainCube.rotation.y += 0.01;
                
                // Add subtle floating animation
                mainCube.position.y = Math.sin(Date.now() * 0.001) * 0.3;
            }
            
            // Transform to Rubik's cube based on scroll progress
            if (scrollProgress > 0.05) {
                const transformProgress = Math.min((scrollProgress - 0.05) / 0.20, 1); // Rubik's cube phase (0.05 to 0.25)
                const pyramidProgress = Math.max(0, Math.min(1, (scrollProgress - 0.25) / 0.20)); // Pyramid phase (0.25 to 0.45)
                const ballProgress = Math.max(0, Math.min(1, (scrollProgress - 0.45) / 0.20)); // Ball phase (0.45 to 0.65)
                const floatingUpProgress = Math.max(0, Math.min(1, (scrollProgress - 0.65) / 0.35)); // Floating up phase (0.65 to 1.00)
                
                // Scale down the main cube
                const mainCubeScale = 1 - (transformProgress * 0.4);
                mainCube.scale.set(mainCubeScale, mainCubeScale, mainCubeScale);
                
                // Show and animate the Rubik's cube pieces
                rubiksCubes.forEach((cube, index) => {
                    cube.visible = true;
                    
                    // Stagger the appearance of cubes
                    const delay = index * 0.03;
                    const adjustedProgress = Math.max(0, Math.min(1, (transformProgress - delay) / 0.5));
                    
                    // Determine current target position based on scroll phase
                    let currentTargetPosition;
                    if (floatingUpProgress > 0) {
                        // Floating up phase - balls float up and fade out
                        cube.visible = false; // Hide cubes
                        cube.ballMesh.visible = true; // Show balls
                        
                        // Interpolate balls floating up from their current position
                        currentTargetPosition = new THREE.Vector3();
                        const fromPosition = cube.ballPosition;
                        currentTargetPosition.lerpVectors(fromPosition, cube.floatingUpPosition, floatingUpProgress);
                        
                        // Position balls floating up
                        cube.ballMesh.position.copy(currentTargetPosition);
                        cube.ballMesh.position.y += Math.sin(Date.now() * 0.001 + index * 0.5) * 0.5; // Continue floating animation
                        
                        // Add rotation to balls
                        cube.ballMesh.rotation.x += 0.02;
                        cube.ballMesh.rotation.y += 0.01;
                        
                        // Balls fade out as they float up
                        const ballScale = (1 - floatingUpProgress * 0.5) * 1.2;
                        cube.ballMesh.scale.set(ballScale, ballScale, ballScale);
                        
                        cube.ballMesh.material.opacity = 1 - floatingUpProgress * 0.7;
                        cube.ballMesh.material.transparent = true;
                        
                    } else if (ballProgress > 0) {
                        // Keep cubes visible during ball transition for smooth morphing
                        cube.visible = true;
                        cube.ballMesh.visible = true;
                        
                        // Interpolate between pyramid position and ball position
                        currentTargetPosition = new THREE.Vector3();
                        const fromPosition = pyramidProgress > 0 ? cube.pyramidPosition : cube.targetPosition;
                        currentTargetPosition.lerpVectors(fromPosition, cube.ballPosition, ballProgress);
                        
                        // Sync positions for smooth morphing
                        cube.position.lerpVectors(cube.initialPosition, currentTargetPosition, adjustedProgress);
                        cube.ballMesh.position.copy(cube.position);
                        cube.ballMesh.position.y += Math.sin(Date.now() * 0.001 + index * 0.5) * 0.5 * ballProgress;
                        
                        // Add rotation to balls
                        cube.ballMesh.rotation.x += 0.02 * ballProgress;
                        cube.ballMesh.rotation.y += 0.01 * ballProgress;
                        
                        // Smooth scale transition - cubes shrink as balls grow
                        const cubeScale = adjustedProgress * (1 - ballProgress * 0.8);
                        cube.scale.set(cubeScale, cubeScale, cubeScale);
                        
                        const ballScale = adjustedProgress * ballProgress * 1.2;
                        cube.ballMesh.scale.set(ballScale, ballScale, ballScale);
                        
                        // Smooth opacity transition
                        cube.material.forEach(mat => {
                            mat.opacity = 1 - ballProgress;
                            mat.transparent = true;
                        });
                        
                        cube.ballMesh.material.opacity = ballProgress;
                        cube.ballMesh.material.transparent = true;
                        
                    } else if (pyramidProgress > 0) {
                        // Show cubes, hide balls
                        cube.ballMesh.visible = false;
                        
                        // Reset opacity for cubes
                        cube.material.forEach(mat => {
                            mat.opacity = 1;
                            mat.transparent = false;
                        });
                        
                        // Interpolate between Rubik's cube position and pyramid position
                        currentTargetPosition = new THREE.Vector3();
                        currentTargetPosition.lerpVectors(cube.targetPosition, cube.pyramidPosition, pyramidProgress);
                    } else {
                        // Show cubes, hide balls
                        cube.ballMesh.visible = false;
                        
                        // Reset opacity for cubes
                        cube.material.forEach(mat => {
                            mat.opacity = 1;
                            mat.transparent = false;
                        });
                        
                        currentTargetPosition = cube.targetPosition;
                    }
                    
                    // Animate cube position (always animate, but scale determines visibility)
                    if (ballProgress === 0 && floatingUpProgress === 0) {
                        cube.position.lerpVectors(cube.initialPosition, currentTargetPosition, adjustedProgress);
                        
                        // Animate scale - now starts from 0 and scales to 1 (same size as main cube)
                        const scale = adjustedProgress;
                        cube.scale.set(scale, scale, scale);
                        
                        // Sync rotation with main cube, but add some pyramid-specific rotation
                        if (!isSpinning) {
                            cube.rotation.x = mainCube.rotation.x + (pyramidProgress * 0.5);
                            cube.rotation.y = mainCube.rotation.y + (pyramidProgress * 0.3);
                        }
                    } else {
                        // During ball/floating transition, sync rotation with main cube
                        if (!isSpinning) {
                            cube.rotation.x = mainCube.rotation.x + (pyramidProgress * 0.5);
                            cube.rotation.y = mainCube.rotation.y + (pyramidProgress * 0.3);
                        }
                    }
                });
                
                // Adjust camera for better view - move further back for each transformation
                const baseCameraZ = 5 + (transformProgress * 3);
                const pyramidCameraZ = baseCameraZ + (pyramidProgress * 2);
                const ballCameraZ = pyramidCameraZ + (ballProgress * 6);
                const floatingUpCameraZ = ballCameraZ + (floatingUpProgress * 4);
                camera.position.z += (floatingUpCameraZ - camera.position.z) * 0.02;
                
                // Move main cube to pyramid top when pyramid forms, or hide it during ball/floating phases
                if (ballProgress > 0 || floatingUpProgress > 0) {
                    // Hide main cube during ball and floating up phases
                    mainCube.visible = false;
                } else {
                    mainCube.visible = true;
                    if (pyramidProgress > 0) {
                        const pyramidTopPosition = new THREE.Vector3(0, 1, 0);
                        mainCube.position.lerpVectors(
                            new THREE.Vector3(0, Math.sin(Date.now() * 0.001) * 0.3, 0),
                            pyramidTopPosition,
                            pyramidProgress
                        );
                    }
                }
            } else {
                // When scrolling back up, animate cubes back to initial spread positions
                rubiksCubes.forEach((cube, index) => {
                    if (cube.visible || cube.ballMesh.visible) {
                        // Stagger the retreat animation
                        const delay = index * 0.02;
                        const retreatProgress = Math.max(0, Math.min(1, (0.05 - scrollProgress + delay) / 0.05));
                        
                        // Hide balls only, show cubes
                        cube.ballMesh.visible = false;
                        cube.visible = true;
                        
                        // Reset opacity and transparency
                        cube.material.forEach(mat => {
                            mat.opacity = 1;
                            mat.transparent = false;
                        });
                        
                        // Animate position from target back to initial spread position
                        cube.position.lerpVectors(cube.targetPosition, cube.initialPosition, retreatProgress);
                        
                        // Animate scale down
                        const scale = 1 - retreatProgress;
                        cube.scale.set(scale, scale, scale);
                        
                        // Hide cube when it's fully retreated
                        if (retreatProgress >= 1) {
                            cube.visible = false;
                        }
                    }
                });
                
                // Reset main cube scale and visibility
                mainCube.scale.set(1, 1, 1);
                mainCube.visible = true;
                
                // Reset camera position
                camera.position.z += (5 - camera.position.z) * 0.05;
            }
            
            // Add mouse interaction to camera
            camera.position.x += (targetRotationY - camera.position.x) * 0.05;
            camera.position.y += (targetRotationX - camera.position.y) * 0.05;
            camera.lookAt(scene.position);
            
            renderer.render(scene, camera);
        }

        // Start animation
        animate();
    </script>
</body>
</html>